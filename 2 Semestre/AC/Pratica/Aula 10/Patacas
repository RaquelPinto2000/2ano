
/*
//Poderiamos fazer assim: Andre-------
static struct _BSTreeNode* _getPointerToKthNodeAux(struct _BSTreeNode* root, unsigned int* k) {
   if(*k == 0) return root;
   if(root == NULL) return NULL;
   struct _BSTreeNode* n1 = _getPointerToKthNodeAux(root->left, k);
   if(n1 != NULL) return n1;
   (*k)--;
   if(*k == 0) return root;
   struct _BSTreeNode* n2 = _getPointerToKthNodeAux(root->right, k);
   if(n2 != NULL) return n2;
   return NULL;
}

// Procura e devolve o K-ésimo nó da árvore contado em-ordem.
static struct _BSTreeNode* _getPointerToKthNode(struct _BSTreeNode* root, unsigned int k) {
 unsigned int aux = k + 1;
 return _getPointerToKthNodeAux(root, &aux);
}
*/



// o que tentei fazer mas nem sequer compilava ;(
//_removeNode -> remove um no
/*
void* BSTreeRemoveKthItem2(BSTree* header, int k) {   slide 50
    //...
    struct _BSTreeNode* root = header->root;
    if(root == NULL){
      return 0;
    }
    if(root->item ==k){
      _removeNode(root)
      return 1;
    }
    if(root->item >item){
      return BSTreeRemoveKthItem2((root->left),k);
    }
    return BSTreeRemoveKthItem2((root->right),k);
}
*/




que eu modifiquei---------:)
/*
void* BSTreeRemoveKthItem2Aux(BSTree* header, unsigned int* k) {
  assert(header != NULL);
//  assert(0 <= k && k < header->numNodes);

  if(*k == 0){
    BSTreeRemove(header,k);
  }
  if(header == NULL) return NULL;
  struct _BSTreeNode* n1 = BSTreeRemoveKthItem2Aux(header->left, k);
  if(n1 != NULL) return n1;
  (*k)--;
  if(*k == 0){
    BSTreeRemove(header,k);
  }
  struct _BSTreeNode* n2 = BSTreeRemoveKthItem2Aux(header->right, k);
  if(n2 != NULL) return n2;
  return NULL;

}

// Procura e devolve o K-ésimo nó da árvore contado em-ordem.
static struct _BSTreeNode* BSTreeRemoveKthItem2(struct _BSTreeNode* root, unsigned int k) {
 unsigned int aux = k + 1;
 return BSTreeRemoveKthItem2Aux(root, &aux);
}

*/

Metodo da bia -------
/*
void* BSTreeRemoveKthItem2(BSTree* header, int k) {
  assert(header != NULL);
  static int flag = 0;
  struct _BSTreeNode* aux = _getPointerToKthNode(header->root, k);
  
  void* kItem = aux->item;
  
  if(flag <= k)
  {
    //left recursion
    BSTreeRemoveKthItem2(header, k);
    //rigth recursion
    BSTreeRemoveKthItem2(header, k);
    flag++;
    
    if(flag == k)
    {
       BSTreeRemove(header, kItem);
    }
  }
}
*/

   /* metodo da bia o que eu mudei
   if(aux<k){
      BSTreeRemoveKthItem2(header, k);

      aux++;
   }else if(aux>k){
     BSTreeRemoveKthItem2(header, k);
     aux++;
   }
   if(aux == k){
     BSTreeRemove(header, pItem);
   }
   return pItem;
   */




O que pensava que tinha de acrescentar ao que deu para dar
  /* if(k == 0){
     BSTreeRemove(header, pItem);
   }
   struct _BSTreeNode* pNode1 = _getPointerToKthNode(header->root, k);
   void* pItem1 = pNode1->item;
   if(pNode1!= NULL){
     return pItem1;
   }
   return NULL;
*/
